{{TOC}}

#ARRAY
##问题
首先，让我们来看一道题目：如何按事先指定的顺序，储存并打印10个数？
比如说，我们希望计算机打印出以下十个数字：0-9。并且，这十个数需要先被储存到一起，然后再打印出来。
解决这个问题，我们需要一种储存结构，它能够按照我们指定的顺序，储存和管理一定量的数据。当我们需要时，我们就可以把这个结构里的数据取出来，进行我们想要的操作，比如打印它们。

我们把这样的一种结构，叫做***数据结构(Data Structure)***。数据结构，就是计算机存储并组织数据的方式。我们借助数据结构，就可以按照我们的需要组织起数据，进行诸如插入、删除、排序、搜索、遍历等操作，用来解决问题或优化问题的解决方案。不同的数据结构，适合解决不同的问题。学习数据结构的重点，就是借助我们对不同数据结构的了解，选择正确的数据结构来解决我们遇到的问题。

而我们用来解决这个问题的数据结构，需要按照线性的顺序来组织固定数量(fixed amount）的数据，支持数据的插入、删除、搜索、遍历、定位（locate）等操作。这种数据结构，我们称为***数组（Array)***。绝大多数主流计算机语言都支持数组功能，在这个笔记中，我们使用Java，提供大部分数组功能的Java类是Arrays类，它是java.util包下面的一个类。

那么，我们如何使用数组来解决上面提到的问题呢？很显然，我们仅需将需要存储的数据输入到一个array对象里，然后再遍历它并打印出相应的结果。

Java代码如下：
	public class Solution {
		public static void main(String[] args) {
			int[] numArray = new int[10];
			for (int i = 0; i < 10; ++i) {
				numArray[i] = i;
			}
			for (int i = 0; i < 10; ++i) {
				System.out.print(numArray[i] + " ");
			}
			System.out.println("");
		}
	}

我们对这个文件进行编译，终端输出的结果是这样的：
	$ javac Solution.java
	$ java Solution
	0 1 2 3 4 5 6 7 8 9 
接下来我们就以Java为例，来介绍数组这种数据结构的原理和功能。

##原理
正如上面介绍的，数组是一种按照线性的顺序来组织固定数量(fixed amount）的数据的数据结构，它所储存的数据称为数组的元素（element）。

在内存中，数组各元素通常也是按照顺序依次排列的，每一个元素占有一块相同大小的内存，这个内存有多大，是元素自身的大小决定的。如果我们知道数组第一个元素所在的内存地址，要访问第k个元素，我们就计算***第一个元素的地址 + 每个元素所占的内存 x (k - 1)***，就可以得到第k个元素的地址了。【图】

我们可以将数组想象为一排画在地上的格子，每个格子里放着一样东西，这样东西就是我们想要存储和管理的元素。同时，每个格子有一个独属于它的，从0往上排列的编号。

###Java Arrays只能储存基础数据类型或引用
有一点需要强调：java的Arrays类所储存的元素只能是基础数据类型（primitive）或实例的引用（reference）。
比如，numArrays[0]对应的内存块里，放置的是一个int，这是基础数据类型。但如果我们新定义一个class，名字叫Person，以一个Person实例作为java数组的元素，记为personArrays[0]，那么数组对应的内存块中所存储的，是new Person(…)时占用的内存的地址，大小是一个字节（byte）。

也就是说，当数组需要保存实例时，它所保存的，只是指向那个实例的一个引用地址，而不是该实例本身。

##功能及复杂度
###数组的功能
有了数组这种数据结构，我们可以非常方便地对数据进行定位（locate）和遍历（iteration），数组也支持插入（add/insert）、删除（delete）操作，但相对就没有那么方便了，此外数组还支持复制（copy）、搜索（search）和排序(sort）操作。

插入、删除、搜索、排序等操作是什么意思，是比较直观的。但定位、复制和遍历操作的含义有些复杂，这里进行一下介绍。

1. 定位（locate），是指给你数据在数据结构中的位置，根据这个位置来提取出数据。比如，这里有一个数组，我们需要提取出这个数组的第3个元素。这很简单，用上面代码中的numArray[2]，就可以提取出numArray数组的第3个元素了。注意，并不是numArray[3]，因为计算机计数是从0开始的。也许你会注意到，上文提到的访问第k个元素的公式，如果从0计数，计算起来会更简单。

	不是所有数据结构都支持定位。“定位”仅对有“顺序”的数据结构适用。试想，画得乱七八糟的一大堆格子，我们要怎样“定位”呢？根本就没有“位置“这个概念。

	方便地定位需要一个表示位置的”key“，才能准确地知道存放那个元素的小格子在哪里。而数组的“key”就是它的顺序编码，比如numArray[0]当中的那个”0“。以后我们会看到HashMap，它的“key”是一个可以进行哈希编码的字符串，而哈希编码本质上仍然是将字符串转换成了数组的顺序编码。我们可以说，顺序编码是方便快速地进行“定位”操作的一种常见思路。

2. 那么，复制呢？你可能觉得，复制很简单，原来的数组有什么，我们新建一个数组，把原来数组的东西原封不动搬过来就行了。

	这种对复制的理解是不全面的。
	上面提到，数组的元素只能是基础数据类型或实例的引用。基础数据类型只需要“搬过来”就可以了，此时旧数组和新数组的元素是相互独立的。
	但如果数组的元素是一个实例的引用，那么，问题就复杂了。
	我们来看以下代码：
		public class Solution {
			private static class Person {
				String name;
				int age;
				public Person(String name, int age) {
					this.name = name;
					this.age = age;
				}
			}
		
			public static void main(String[] args) {
				Person[] p1 = new Person[1];
				p1[0] = new Person("Tom", 13);
				Person[] p2 = new Person[1];
				p2 = Arrays.copyOf(p1,1);
		
				System.out.println(p1[0].name);
				System.out.println(p2[0].name);
				
				p1[0].name = "Mary";
		
				System.out.println(p1[0].name);
				System.out.println(p2[0].name);
			}
		}
	
	四个打印命令，分别输出了什么呢？
	这是输出的结果：
		Tom
		Tom
		Mary
		Mary // Also changed!
	
	新复制的数组各元素，在默认情况下，复制的也是相应实例的引用，两个引用指向一个地址。此时，任何一个数组操作改变了那个地址的实例内容，另一个数组的对应元素也会相应变化。这种情况下，数组元素指向的实际内容，也就是该实例，其实并没有被“复制”，被复制的只是它的引用。这种复制，叫做“浅复制”（Shallow Copy）。
	如果我们希望真的复制所有元素对应的实例，修改一个数组元素对应的实例时，另一个数组元素对应的实例不变，我们就需要使用“深复制”（Deep Copy）。它和”浅复制“的区别就在于，新的数组里面的实例，内容和复制时旧数组对应的实例是一样的，但却是新的一块内存下声明的新实例。修改旧实例时，新数组的内容不会改变。

	注意String的特殊性：虽然本质是pass by reference，但因为invariable，所以功能上看起来像是pass by value.
			public class Solution {
			  public static void main(String[] args)
			  {
			    String[] a1 = new String[1];
			    a1[0] = "Tom";
			    String[] a2 = a1.clone();
			    System.out.println(a1[0]);
			    System.out.println(a2[0]);
			    
			    a1[0] = "Mary"; // Assigned to a new address!
			    System.out.println(a1[0]);//"Mary"
			    System.out.println(a2[0]);//"Tom"
			  }
			}
	深浅复制的联系与区别，如图所示【图】。
	

3. 最后是遍历。遍历是什么呢？简单地说，就是把数据结构中所有的元素都访问一遍且不重复。数组遍历只需要把所有元素按线性顺序访问一遍即可。一些数据结构的遍历更为复杂，我们将在接下来的内容中详细介绍。
	
	这些功能，数组都支持。其中，定位功能是数组的强项，它可以特别简单快捷地支持定位功能。
	
	我们注意到，之前一直都在用“方便”“简单快捷”这些词来形容我们的数据结构支持某些功能操作的能力。那么，我们有没有办法，把这些模糊的形容词精细化、量化呢？这样，我们就可以比较不同数据结构对同一功能的支持程度。
	
	计算机科学家为我们提供了一个强大的武器：复杂度，来解决这个问题。
	
###复杂度及Big(O)
一种数据结构所支持的操作，有其时间上的“代价”，我们用时间复杂度这个概念来衡量。时间复杂度，是指算法运行时间与输入数据量的函数关系，常用大写字母O表示。时间复杂度是渐进的：当输入数据量逐渐增加以至趋于无穷时，算法运行时间渐近于某个关于数据量n的函数。

时间复杂度不仅有Big O一种表述方式，而且Big O的数学含义较为复杂，可以参考《算法导论》等材料查看细节。我们学习数据结构时，只需要知道Big O表示输入量和操作运行时间的关系。而且，我们只取变化量最大的关系（比如多项式中最高次数的项），而且所有的系数都是1。

比如，如果一个操作对任何大小为n的输入，最多需要2n^2 + 3n时间运行，这个操作的时间复杂度仍然是O(n^2)，因为n趋于无穷时，系数和n项相比之下就没有那么“重要”。这一性质，是Big O的渐进性质造成的。【准确？】

有些操作在不同情况下时间复杂度也是不一样的，通常分为平均情况和最坏情况两种，我们通常使用最坏情况来衡量，有时也使用平均情况。本笔记除非特别说明，所指都是最坏情况。

现在，我们来看几种常见的时间复杂度，及其常见的例子。

- O(1)
	这是最理想的时间复杂度，它说明操作的运行时间是恒定的，不受输入的数据所影响。
	其实，O(1)的算法也许花费了很长的绝对时间。但它不受输入数据的大小影响，所以输入的数据很大的时候，O(1)算法就会显得越来越“省力“。这里需要再次强调，Big O是输入量和运行时间相对的关系，而不是绝对的运行时间。
- O(log n)
	说明输入数据和运行时间是log n的关系，运行时间比数据的增长慢一些。一个典型的O(log n)算法是Binary Search算法，我们后面会讲。
- O(n)
	说明运行时间和输入数据的增长速度是一致的，又称为线性（linear）时间。常见于循环中，Linear Search也是O(n)的。
- O(n log n)
	通常，这一复杂度的出现说明O(n)的操作被执行了log n次，或者O(log n)操作被执行了n次。常见于QuickSort和MergeSort等排序算法，是排序算法的一种理想的复杂度。
- O(n^2^)
	又称为二次(Quadratic)时间，运行时间增长速度是输入数据增长速度的平方。比如，输入了3倍的数据，则运行时间是以前的9倍。常见情况下，这就是一种比较差的复杂度了。常见于嵌套for loop，比如BubbleSort。
- O(2^n^)
	指数复杂度，运行时间是2的n次方倍，效率极低，应当避免。斐波那契数列按照定义可以用指数复杂度的递归算法实现：
		public int Fibonacci(n) {
			if (n == 1 || n == 2)
				return 1;
			if (n > 2)
				return Fibonacci(n-1) + Fibonacci(n-2);
		}
	
	为什么是2^n^呢？因为每一次呼叫递归函数，都会打开新的一层栈桢（stack frame），形成一个层数为n - 1的二叉树，从每一层有2^0^项，延展到每一层有2^n-1^项，2^0^ + ... + 2^n-1^是2^n^-1。注意这个二叉树不是完全的，2^n^只是趋近值。
- O(n!)
	阶乘复杂度，注意它比指数复杂度更慢，是应当绝对避免的。
	*Permutation
	
###数组各操作的时间复杂度
有了时间复杂度这个武器，我们就可以来看看数组的各种功能操作具体的快慢程度了。

1. locate: O(1)
	这是数组最擅长的操作：给定一个顺序编码，可以马上访问编码对应的“格子”中的元素。无论数据集有多大，这一操作都是固定时间的。
2. insert/delete: O(N)
	相比之下，数组的插入和删除操作，就慢了不少。试想我们在第2和第3个元素之间，插入一个元素，那么第三个元素以后的元素都要后移一位。假如我们在数组头部插入一个元素，那么头部到尾部所有元素都要后移一位，这种最坏情况下，运行复杂度为O(N)。
3. search: 如果数组本身没有排序，则为O(N)，因为只能使用Linear Search算法。如果数组已排序，则为O(log N)，因为可以使用Binary Search算法。这两种搜索算法，后面会详细讲。
4. iteration: O(N)，遍历一遍数据肯定是O(N)，所以以后我们就不再讨论遍历的复杂度了。

【表】

##Java相关方法
1. 定位：提取arr[i]即可。
2. 插入：arr[i] = newElem，同时将后面的元素顺序后移//，此时有可能溢出，根据需要设计此时的反应，比如抛出异常。删除类似。
3. 复制：有三种方法，都是浅复制：
	- Arrays.copyOf(AnyType[] arr, int len)
	- System.arraycopy(AnyType[] ore, int start, AnyType[] dest, int end, it len)
		这一方法会声明一个新的数组，占用一块新的内存。
	- arr.clone()
		这一方法也会声明新数组。
	
4. 遍历：用for loop循环一遍即可。
5. 相等： “==”, Arrays.equals()和Arrays.deepEquals()
// Code
【图】
6. 其他：
sort()：用来对array进行排序。
binarySearch()：在排好序的array中寻找元素。
System.arraycopy()：array的复制。